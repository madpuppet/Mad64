#pragma once

class Cpu6502
{
public:
    Cpu6502();

    typedef DMFastDelegate::FastDelegate0<> Decode;

    enum AddressingMode
    {
        AM_Implied,              // operand
        AM_Immediate,            // operand #value
        AM_Relative,             // operand value
        AM_ZeroPage,             // operand value
        AM_ZeroPageX,            // operand value,x
        AM_ZeroPageY,            // operand value,y
        AM_IndirectX,            // operand (value, x)
        AM_IndirectY,            // operand (value), y
        AM_Absolute,             // operand value
        AM_AbsoluteX,            // operand value,x
        AM_AbsoluteY,            // operand value,y
        AM_Indirect              // operand (value)
    };

    enum CpuStatusRegisters
    {
        SR_Carry = 1,
        SR_Zero = 2,
        SR_Interrupt = 4,
        SR_Decimal = 8,
        SR_Break = 16,
        SR_Overflow = 64,
        SR_Negative = 128
    };

    struct Registers
    {
        u16 PC;
        u8 A;
        u8 X;
        u8 Y;
        u8 SR;
        u8 SP;

        struct Opcode* op;      // opcode fetched
        u16 operand;            // opcode data fetched
        u32 frameCycle;         // cycles this refresh
        int decodeCycle;        // current decode cycle
        bool delayCycle;        // delay cycle has been generated by branch or crossing a page

        // helpers
        void SetNZ(u8 val)
        {
            u8 N = val & SR_Negative;
            u8 Z = (val & 0xff) ? 0 : SR_Zero;
            SR = (SR & ~(SR_Negative | SR_Zero)) | N | Z;
        }
    };

    struct Opcode
    {
        const char* name;
        AddressingMode addressMode;
        u8 opc;
        u8 cycles;
        Decode decode;
    };

    void Reset(u16 cpuStart);

    Registers& Regs() { return m_regs; }

    bool IsOpcode(const char* text);
    Opcode* FindOpcode(const string& name, AddressingMode am);

    // return true when an opcode has completed
    bool Step();

    void SetMemReadByte(const ReadByteHook& hook) { MemReadByte = hook; }
    void SetMemWriteByte(const WriteByteHook& hook) { MemWriteByte = hook; }

private:
    // HOOKS
    ReadByteHook MemReadByte;
    WriteByteHook MemWriteByte;

    // REGS
    Registers m_regs;

    // array of 256 opcodes matching machine language value
    Opcode m_opcodes[256];

    // array of unique opcode names for quick lookup of string->opcode
    vector<Opcode*> m_uniqueOpcodes;

    // decoders
    u16 Decode_ZeroX_Addr();
    u16 Decode_ZeroY_Addr();
    u16 Decode_Abs_Addr();
    u16 Decode_AbsX_Addr();
    u16 Decode_AbsY_Addr();
    u16 Decode_Ind_Addr();
    u16 Decode_IndX_Addr();
    u16 Decode_IndY_Addr();

    void Decode_SEC();
    void Decode_CLC();
    void Decode_TAX();
    void Decode_TAY();
    void Decode_TSX();
    void Decode_TXA();
    void Decode_TXS();
    void Decode_TYA();
    void Decode_ADC(u8 M);
    void Decode_ADC_Imm();
    void Decode_ADC_Zero();
    void Decode_ADC_ZeroX();
    void Decode_ADC_Abs();
    void Decode_ADC_AbsX();
    void Decode_ADC_AbsY();
    void Decode_ADC_IndX();
    void Decode_ADC_IndY();
    void Decode_AND(u8 M);
    void Decode_AND_Imm();
    void Decode_AND_Zero();
    void Decode_AND_ZeroX();
    void Decode_AND_ZeroY();
    void Decode_AND_Abs();
    void Decode_AND_AbsX();
    void Decode_AND_AbsY();
    void Decode_AND_IndX();
    void Decode_AND_IndY();
    void Decode_EOR(u8 M);
    void Decode_EOR_Imm();
    void Decode_EOR_Zero();
    void Decode_EOR_ZeroX();
    void Decode_EOR_ZeroY();
    void Decode_EOR_Abs();
    void Decode_EOR_AbsX();
    void Decode_EOR_AbsY();
    void Decode_EOR_IndX();
    void Decode_EOR_IndY();
    void Decode_ORA(u8 M);
    void Decode_ORA_Imm();
    void Decode_ORA_Zero();
    void Decode_ORA_ZeroX();
    void Decode_ORA_ZeroY();
    void Decode_ORA_Abs();
    void Decode_ORA_AbsX();
    void Decode_ORA_AbsY();
    void Decode_ORA_IndX();
    void Decode_ORA_IndY();
    void Decode_LDA_Imm();
    void Decode_LDA_Zero();
    void Decode_LDA_ZeroX();
    void Decode_LDA_Abs();
    void Decode_LDA_AbsX();
    void Decode_LDA_AbsY();
    void Decode_LDA_IndX();
    void Decode_LDA_IndY();

    void Decode_STA_Zero();
    void Decode_STA_ZeroX();
    void Decode_STA_Abs();
    void Decode_STA_AbsX();
    void Decode_STA_AbsY();
    void Decode_STA_IndX();
    void Decode_STA_IndY();

    void Decode_LDX_Imm();
    void Decode_STX_Zero();
    void Decode_STX_ZeroY();
    void Decode_LDY_Imm();

    void Decode_DEX();
    void Decode_DEY();
    void Decode_BNE();
    void Decode_RTS();
};

